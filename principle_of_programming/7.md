# UNIX 思想 10~17

## 3.47 驚き最小の原則

- ソフトウェアを使う人の驚きを最小にする -> ユーザーの学習コストが下がる

- ユーザーの既知を活用する
  - よく似たソフトウェアのインターフェースをモデルにする
  - 想定ユーザーの特徴を考慮する
  - 伝統に注意を払う
  - 「一見似ているが微妙に異なる」を避ける

---

- httpHelper.js の関数名は getXXX ではなく fetchXXX の方が良かったのかも・・・orz

- 映画館の予約ページとか参考にするとよかったのかも。。。

## 3.48 沈黙の原則

- ソフトウェアの表示は最小限にする。

- 表示が多いと重要なことが埋もれてしまう。

- ソフトウェアの出力を別のソフトウェアの入力にするにも不要な情報が多いとうまくいかない

---

- エラーを alert で表示させるべきではないというのはここに通じてそう

- vervose のレベルを変えられるようなオプションを作るべき

## 3.49 修復の原則

- プログラムの処理の過程でエラーの回復に失敗した場合は目立つようにエラーを表示してプログラムを停止させるべき

- エラーのまま暴走してデータを破壊したりするのが最悪のシナリオ

- 入力については寛容に（ちょっと間違った入力ではエラーは出さずに意図を汲み取ることができるようにする）

- ただし、「仕様の解釈」を寛容にしては HTML の悲劇の二の舞になる

---

- https://sakichin.com/chapter01/chapter01_step04_09.html

- そもそも様々なブラウザからのアクセスを想定して web ページを作る必要がある現在の状況がおかしい

## 3.50 経済性の原則

- 良いハードウェアを使おう（CPU、メモリ、モニタ、キーボード）

- 良いソフトウェア使おう（ライセンス）

- それ以外の環境も整えよう（情報へのアクセス、セキュリティ面をガチガチにするのも考えもの）

---

- 椅子・机とか飲食物とかも

## 3.51 生成の原則

- 「コードを書く」コードを書く

- 自動生成コードは安価で高品質

  - コンパイラやインタプリタもコードジェネレータと言える

---

- コードジェネレータという言葉自体初めて聞いた・・・

- 参考：[怠惰なエンジニアのためのコード生成
  メタプログラミングでテストを楽する方法](https://logmi.jp/tech/articles/294502)

- 自作スニペットとかを作るのもこれなのかなあ・・・

## 3.52 最適化の原則

- 「遅くて、リソースを大量に消費するが正しく動作する実装」-> 最適化の順序を踏む

- 一度「正しい」実装をしておかないと、透明性や単純性が犠牲になる。全体最適化の妨げにも成る

---

- 一度コードを書いたあとで「こここうすればよかったなあ・・・」みたいな後悔って結構するイメージ

- 最適化をしつつ正しく実装するのは難しい。愚直に一度考えるのが大切。

- 愚直な実装を一度行って動かすことでボトルネックもわかる

## 3.53 多様性の原則

- 「唯一の正しい方法がある」という考えを捨てる。そのような方法はない。

- 「何が最適のなのか」はそのソフトウェアの用途によっても変わるが、すべての用途を開発の段階で想像することは不可能

- より良いやり方を求め続ける姿勢が大切。

- そのためにもプログラムの拡張性を高めた設計にしておく必要がある

## 3.54 拡張性の原則

- 拡張できる設計にしておく

- プログラムを取り巻く環境は変化し続ける -> その変化に合わせてプログラムも修正する必要がある

- 不必要な機能を追加するのではなく、必要になった時にその機能を追加できるようにしておく

- 「～が必要になったら」というコメントを残しておく

- データ形式にも言えるらしい（がよく分からなかった）

---

- 拡張性に関しては何度も記述されてるね
