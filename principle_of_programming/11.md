## パフォーマンスチューニングの箴言

- コードの実行速度よりも読みやすさを重視
- コードの実行速度は愚直な実装を一度行ってから
- コードの最適化による悪影響

  - 可読性 ↘
  - 品質 ↘
  - 複雑性 ↗
  - 保守性 ↘
  - 作業コスト ↗

- まずは愚直な実装で読みやすいコードを書く。最適化はそれから。
- ただしアーキテクチャ設計時は最初からパフォーマンスを考慮すべき

  - 後から最適化を行うのが困難
  - 早い段階でパフォーマンステストを行っておく->パフォーマンスを大きく下げる要因となった修正に気づくことができる

- 最適化の手順

  - 最適化の必要性を検討
  - パフォーマンスを測定し、ボトルネック箇所を特定
  - 修正
  - 再測定し最適化の効果を確認
  - テスト

- ボトルネック箇所を見つけるにはプロファイラを使用する

---

- 実際の業務では最初から実行速度を考えたコードを書くことが求められる場面はありそう

- プロファイラ

  > プログラムの起動から終了までの間に行われた関数呼び出しなどの動作を逐一記録し、時系列に並べて出力（トレース）したり、呼び出し回数や処理時間などを集計して総計や平均などの要約（プロファイル）として出力する。CPU 使用率やメモリ占有量などを時系列に記録し、どこを実行しているときに増大・減少しているかを調べられるものもある。

  > 開発者はプログラム中のサブルーチンなどのうち、実行頻度の高い箇所や実行時間の長い箇所を知ることができる。そのような箇所はホットスポット（hotspot）あるいホットパス（hot path）などと呼ばれ、その部分を集中的に改良することで性能を効率的に向上させることができる。

- 最適化の例
- プロファイラの例

## エゴレスプログラミング

- 「よりよいものをつくる」ことに注力する。
- 自分のうぬぼれやプライドを捨てる。
- レビュワーもレビュイーもこの意識を持つ
- アドバイスは謙虚に受け入れて高めあっていこう的な
- エゴレスプログラミングの十戒
- とはいえ自我を捨ててはいけない。バランスが大事

---

- エゴレスプログラミングの十戒はデスクに貼っておきたい

## 1 歩ずつ少しずつ

- プログラミングを行うときはステップを細かく刻む
- 思考も同じ
- 複数作業を 1 ステップで同時に行うと干渉して失敗しやすい
- ステップが細かいと後戻りも簡単
- 例）関数名変更と関数の移動は別々に行う。テストコードと本番コードは両者をちょっとずつ書いていく
- 論理的思考のコツ
  - 粘り強く考える
  - 思い込みは排除。別の可能性も考える
  - 思考の結果は覚える。覚えるのは大変なので書く。書くことで思考の整理もなされる
  - 直感も大切に。情報整理の方法はひらめきを試してみる

---

- CISC 的に作業・思考を行う。思考が速い人はクロックが速い
- 来た道を戻れることがわかっていると前に進むのは怖くない
- こまめにコミット大切
- コードを修正しようとして、大きく変えて動かなくて、結局ロールバックして実装し直すみたいなことはやりがちな気がするけど良くない

## TMTOWTDI（There's more than one way to do it）

- ツールを設計する場合は達成するための手段を複数用意する
  - ツール：プログラミング言語、DSL、API
- 「（そのツールを使って）やりたいことが簡単なときは簡単に行えて、難しいことにも対応できる」のが理想
- システムを作る際はどこかが複雑さを肩代わりする必要がある。それはツール側であるべきなのかクライアント側であるべきなのか
- 最適化問題 $ \\ {\rm{subject\ to}}\ c_{\rm{tool}}+c_{\rm{client}}=C_{\rm{const}} \\ {\rm{min}} \ n_{\rm{tool}}c_{\rm{tool}}+n_{\rm{client}}c_{\rm{client}} $


