# アーキテクチャ根底技法

- よいソフトウェアアーキテクチャ構築のための基礎原理
- 10 個の技法からなる
  - 抽象
  - カプセル化
  - 情報隠蔽
  - パッケージ化
  - 関心の分離
  - 充足性、完全性、プリミティブ性
  - ポリシーと実装分離
  - インターフェースと実装の分離
  - 参照の一点性
  - 分割統治

## 3.12 抽象

- 概念的な千引き
- 抽象＝捨象＋一般化
  - 捨象：自分の目的の性質のみを取り出す
  - 一般化：共通の性質を取り出すこと

---

- 捨象：オブジェクトを作成するときプログラムに不必要なプロパティやメソッドを持たせないこと

- 一般化：[scikit-learn の例](https://github.com/scikit-learn/scikit-learn/blob/2beed5584/sklearn/svm/_classes.py#L443)

  - 一般化した抽象クラス・抽象関数を作ると汎用的に使える

- sum とか average(mean) とか頻繁に使う

## 3.13 カプセル化

- 関連のあるデータとロジックをグルーピング=>モジュール
- メリット

  - コードが見やすくなる

  - 影響範囲をモジュール内に限定できる=>変更のハードルが下がる

  - 部品として再利用性が高まる

---

- MVC モデルで各ページのコントローラをまとめてモジュール化

- ここでの「カプセル化」という用語は世間的に言われている「カプセル化」とはカバーする意味が狭い(情報隠蔽は含まない)

- バックエンドとフロントエンドみたいな分け方も広義のカプセル化と言える？

## 3.14 情報隠蔽

- モジュールの実装(データ＆ロジック)はモジュールのユーザーから見えないようにする

- インターフェースが小さくなればユーザーがそのモジュールを使うのに必要な情報量が小さくなる=>モジュールを使いやすくなる

- 非公開部分が多ければ、変更の影響をモジュール内部に留めておける

---

- 使用者に使われているメソッドの仕様変更=>ユーザーのコードにまで影響が波及する

- パブリックとプライベートをちゃんと分けて設計しようってこと

```Python
class object1():
    __privateValue = 3
    _privateValue = 2
    publicValue = 3

    def __init__(self):
        pass

    def __privateFunc(self):
        print("I'm private")

    def _privateFunc(self):
        print("I'm used as if private, but actually public")

    def publicFunc(self):
        print("I'm public")


obj = object1()
```

## 3.15 パッケージ化

- モジュールをグルーピングしてパッケージ化

- メリット

  - 大量に作成されたモジュールに起因するソフトウェアの複雑度を下げる
  - モジュールの管理がしやすい
  - パッケージ単位での再利用

- パッケージは「ソフトウェアのビルド方法を示すマップ」

  - この文章理解できない

- パッケージはボトムアップで設計する
  - 最初からパッケージ構造を見通すことは難しいから諦める。モジュールを作成して意味のある単位に分けられる段階に至ったときにパッケージ構造を設計する

---

- モジュール=>パッケージは階層構造の話(SLAP)のときと同じ

- やりたいことができるモジュールをパッケージ名からあたりをつけて探せる

## 3.16 関心の分離

- 「関心」ごとにコードを分離(モジュール化)

- (例) MVC モデル

- メリット

  - 「関心」ごとに修正できるので、変更に伴い必要な理解するコード量を抑えられる。影響も波及しにくい
  - 「関心」ごとに開発するので分業しやすくなる(共同開発でコンフリクトが起きにくい)

- アスペクト指向プログラミングと言う技術も紹介されていたが少なくとも現状はあまり人気はなさそう。
  - もし概要を知りたければ[このページ](https://thinkit.co.jp/free/compare/15/5/1.html)が良さそう

## 3.17 充足性、完全性、プリミティブ性

- 充足性

  - モジュールが表現しようとしている抽象が、それを伝えるために十分であるか

  - これが満たされていないと、ユーザーはモジュールの本質を見失う

- 完全性

  - モジュールが表現しようとしている抽象が、すべての特徴を備えているか

  - これが満たされていないと、ユーザーがやりたいことがそのモジュールでできないことがある

- プリミティブ性

  - モジュールが表現しようとしている抽象が、すべて純粋であるか

  - これが満たされていないと、ユーザーはモジュールの使い方に戸惑ってしまう

---

- この節は説明文が理解しにくい
- 充足性

  - 例えば python の collections.deque が例
  - deque はスタックとキューの一般化
  - スタックとキューとして使うなら`append() appendleft() pop() popleft()`の 4 種類も必要ない。しかし 4 つとも用意されている

```Python
from collections import deque

# キュー
queue = deque()
queue.append(1)
queue.append(2)
queue.append(3)
print(queue.popleft())
print(queue.popleft())
print(queue.popleft())

print()

# スタック
stack = deque()
stack.append(3)
stack.append(4)
stack.append(5)
print(queue.pop())
print(queue.pop())
print(queue.pop())

# appendleftは使うことなくキューとスタックとして使用できるがしかしメソッドとして用意されている
```

- 完全性
  - これは分かりやすい。足りないメソッド、変数があったらユーザーはどうしようもない
- プリミティブ性
  - モジュールの抽象度にあったメソッドを用意しようということ
  - 特定の場面での使用に特化したメソッドは不要

## 3.18 ポリシーと実装の分離

- モジュールレベルでポリシーと実装を分離すべき

- ポリシーモジュール：そのソフトウェアの前提に依存する、ビジネスロジックや、その他のモジュールの引数選択を行う部分。そのソフトウェアに特化

- 実装モジュール：そのソフトウェアの前提に依存しない、独立したロジック部分。ソフトウェアの前提条件については、モジュールに対する引数として与えられる。他のソフトウェアでも再利用可能

---

- ちょっと言っていることよく分からない

- [このサイト](https://qiita.com/ShinNakamura/items/dee3eddc644e44a4f2c5)がとても分かりやすい例が書いてあった。(菊川はこれを読んで理解できた気がする)

- 記事中にも記述があるが、なにがポリシーでなにが実装なのかを判断するのも難しそう

- 個別ページのコントローラモジュールはポリシーで、n---.py なんかは実装な気がする

## 3.19 インターフェースと実装の分離

- モジュール内部ではインターフェースパートと実装パートに分離する

- インターフェースパート：モジュールが持つ機能と使用方法を定める部分。ユーザーによってアクセス可能な部分

- 実装パート：モジュールの持つ機能を実現している部分。モジュールが内部で使用するデータとロジック部分。

- ユーザーはインターフェースパートだけ分かればよく、開発者は変更の影響を実装パートに閉じ込めることができる

- 「インターフェースに対してプログラミングするのであって、実装に対してプログラミングするのではない」

---

- [scikit-learn のコード例](https://scikit-learn.org/stable/modules/generated/sklearn.svm.LinearSVR.html)で説明

  - `fit()`や`predict()`がインターフェース
  - `_validate_data()`や`_decision_function()`が実装
  - 確かに scikit-learn でも分離されていることが確認できた

- 「インターフェースに対してプログラミングするのであって、実装に対してプログラミングするのではない」
  - 別モジュールから使うときはインターフェースを介すようにするってことかな

## 3.20 分割統治

- 大きい問題は小さな問題に分割して考える。

- 考える範囲が小さくなる

- これはほぼすべてのことに対して言える(本節の最後の部分)

- マージソートのような発想

- 並列化も同じ

---

- 関数を分けるみたいな話は言わずもがな

- WBS とかアジャイルのスプリントとかも同じ

- マイクロサービスの考え方とか
