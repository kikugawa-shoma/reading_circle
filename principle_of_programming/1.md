# プリンシプルオブプログラミング

## まえがき

- この本は「良いコード」を書けるプログラマになってもらうことを目的とした書籍である

  - 「良いコード」：読みやすく、書きやすく、バグが発生しにくく、修正しやすい

- そのために本書では「プリンシプル」を紹介していく

  - プリンシプル：原理、原則、主義、方針、思想、習慣
  - 「良いコード」を書くためのエッセンス

- すべての技術はプリンシプルを具現化したもの

- つまりプリンシプルが分かれば、技術を深く理解でき、適切に使える

## この本の読み方

- 7 カテゴリーのプリンシプルをそれぞれ章立てて説明。
- 新しい章を読み始めるときはそれぞれの内容・目的を記したこの部分を読み直そう

  - 1 章：プログラミングの前提を説明。この章の内容は「プログラミングとはこういうもの」として受け入れる

  - 2 章：基本的な決まりごとを説明。あくまで原則なので、例外もある。

- コード例はあえて掲載していない。抽象的な概念を説明している。コード例は自分で考えて見るのが良い。

## 第 1 章

### 1.1 プログラミングに銀の弾丸はない

- ソフトウェアは本質的に困難（ソフトウェア=>困難）
  - 複雑性：行数、構成要素の依存関係も多い
  - 同調性：この上なく複雑な実世界と同調しなくてはならない
  - 可変性：（同調性の結果）変化し続けることが求められる
  - 不可視性：ソフトウェアの全貌を「見る」ことができない。
  - 少ないコード量で便利なシステムを提供することなど不可能
- 困難性に（プリンシプルに従ってプログラミングを行うことで）少しでも抗うことが大切。特効薬などは存在しないことを認める

- 偶有的な部分の改善が重要
  - ソフトウェア自体は本質的に困難だが、それ以外には特効薬がある事が多い
  - ビルド環境、プログラミング言語、ライブラリ、フレームワーク
  - CI や CD はそれの最たる例
  - 偶有的な部分にかける時間をなるべく削るような仕組みを整える

### 1.2 コードは設計書である

- 設計書をインプットとしてコードができあがるのではない
- プログラミングまで含めて設計である
- プログラミングの工程まで進んで初めて分かることもある。
- 基本設計、詳細設計でも決めきれないが、ソフトウェアを完成するには決める必要のある事項がたくさんあり、プログラミングの工程ではそれを行っているため、プログラミングも設計であると言っている。
- つまり「コード=設計書」。むしろコードこそが真にすべてが書かれた設計書
- プログラミングは仕様をコードに落とし込むという機械的な作業ではなく創造的な行為
- ドキュメントにはコードからは読み取ることが難しい情報を重点的に盛り込む
  - 開発環境を理解するための情報
  - 全体から俯瞰したソフトウェアのアーキテクチャ

### 1.3 コードは必ず変更される

- 不具合修正、ソフトウェアの外的環境に対応する必要 => コードの変更が必要
- 新規開発中も修正の作業は入る(リファクタリングなど)
- 変更に強いこと、読みやすいこと、が求められる
  - コードは書かれている時間よりも読まれる時間の方が長い
  - 多少書くのに時間がかかろうとも読みやすいコードを書いたほうが長期的なコストは安く済む

## 第 2 章

### 2.1 KISS(Keep It Simple Stupid)

- コードはシンプルに保つ。

- 「動作させるために、もっともシンプルなものはなにか？」を問いかける

- プログラミングに限らず、エンジニアリング全般に言えること

- オッカムの剃刀

---

- オッカムの剃刀は機械学習分野でも有名

### 2.2 DRY(Don't Repeat Yourself)

- 同じこと繰り返さない

- コードで言えば同じコードは書かない(そのための機能がプログラミング言語には実装されている)

- 定数ベタ書きも NG

- コードの処理をそのままコメントに書くのも NG

- 積極的に関数化、モジュール化

- 自分の開発環境についても同じ。継続的 CI/CD

- データベースにおいての DRY 達成手段は正規化

---

- コードを別の箇所からコピペしたときは注意！

- オブジェクトの継承

- 自動化できるところは自動化する(シェルスクリプト、コードフォーマッタ、スニペット、、、)

- リファクタリング大切

- 重複をなくす活動を進めるためにもテストコードを書いておくべし（テストコードがないと変更するのが大変）

### 2.3 YAGNI(You Aren't Going to Need It)

- コードは現状で必要最低限なもののみ書く。将来的に必要そうなものを予測して書かない

- 予測は当たらないし、外れたときのコストが大きい（書くコスト、後からコードを読んで不要箇所を特定し削除するコストの両方が必要）

- 汎用性 ＜ 単純性

- 無用な機能は UX を下げる

---

- これはアジャイル開発の精神にも通じてそう

- テレビのリモコンにはいっぱいボタンが付いているがよく使うボタンは結局一部

### 2.4 PIE(Program Intently and Expressively)

- コードは「人」が読む唯一の完全な「設計書」

- コードより他に正確にソフトウェアを記述するものはない

- どう動くのかが伝わりやすいようなコードを書くことを心がけるべし

- コードは「読まれる時間」>「書かれる時間」

- コメントにはコードの Why を書く。What と How はコード自体で伝える。コードで表現しきれない部分をコメントで補う

---

- コーディング規約はこのためでもある？（共通の書き方を決めておくことでチーム内のコードの理解を早める）

- 変数名をしっかり考える

- 3 項演算子とかリスト内包表記とか複雑な条件節とか危険な気がする

- 一文一義も大切

理解するのが難しいコードたち

```python
#3項演算子
x = [1,2,6,2,4,5,9]
S = 'positive' if x > 0 else 'negative' if x < 0 else 'zero'

#リスト内包表記
A = [ i for i in range(1,100) if i % 3 == 1 or i % 3 == 2 ]

#複雑な条件節
if x + y < 1 and -x + y < 1 and x + y > -1 and -x + y > -1:
```

### 2.5 SLAP(Singele Level of Abstraction Principle)

- コードの抽象度のレベルは適切な段数の階層構造を持たせる

- 抽象度の低い関数（より具体的な処理を行う関数）がちょうど 1 段だけ抽象度の高い関数を呼ぶような構造

- 階層化されたコードは書籍の構造と対比できる（本文参照）

- オブジェクトの抽象度も同様（抽象度の低いオブジェクトが抽象度がちょうど 1 段だけ高いオブジェクトを継承する構造）

---

- OSI 参照モデル、TCP/IP とかも同じ思想だと感じた

- 階層化することは、複雑なものを少しでも整理してわかりやすくするのに有効な手段。プログラミングでも使えるはず。

- 人間は雑多なものを階層化して理解しようとする生き物（家系図、生物の分類、モノタロウの倉庫 etc...）

### 2.6 OCP(Open-Closed Principle)

- 拡張に対して開いて、修正に対して閉じている

- 影響範囲が小さくなるようにコードは書く

- 「ソフト」ウェアなんだから変更できなきゃ本末転倒

- インターフェースをはさむことで柔軟性を持たせる（ただしやりすぎ注意）

---

- これは webAPI サーバを別で立てる理由のひとつ

- ブラウザというインターフェースがあるからこそ簡単に web ページを閲覧できている。(JS のどのバージョンが動いているとか意識しなくてよい)

- 「流動的要素のカプセル化」が自分は理解しづらかった。[以下引用](https://charagaki.com/2019/04/30/the-object-oriented/)

  > 例えば、キャラクターによって、「殴る・蹴る・投げる」という攻撃技のいずれかが使えるとする。
  > 攻撃技の振る舞いに落とし込むにあたってどうできるだろう。
  > 大きく 2 つの方法が考えられる。
  > 1 つ目は、攻撃のタイプをデータメンバーとして追加し、それぞれの攻撃技の振る舞いのメソッド naguruKogeki() 、 keruKogeki、nageruKogeki をそれぞれメソッドとして用意したうえで、kogeki メソッドから攻撃タイプで分岐させていずれかのメソッドを呼び出す方法が考えられる。
  > この時点で、見通しが若干悪いのと、キャラクターは全く利用しないメソッドを抱えることなる。
  > 2 つ目は、今まで通りの継承の考え方を導入してみる。
  > 抽象クラスとしてのキャラクタークラスを用意して、そのクラスに kogeki() メソッドを用意する。 こうした上で、派生クラスとして、殴る系・蹴る系・投げる系の 3 つの派生クラスに分け、 kogeki() を Override する。 クラスの数は増えるが、見通しはよくなる。
  > ここでキャラクターに別の振る舞いを必要になったらどうするか、例えば、防御という振る舞いが必要になったとする。
  > キャラクターによって、防御の方法のいくつかあって、「ガードする・かわす・受け止める」といった違いがあるとする。
  > ここでも攻撃の時と同じように考えると、2 つの方法が考えられる。
  > 防御のタイプを表すデータメンバーを用意し、それぞれに振る舞いのメソッドを用意して、bogyo メソッドから分岐させて呼び出す方法と、派生クラスとして用意する方法だ。 1 つ目の場合、bogyo メソッドの中で防御タイプで分岐させる必要がある。
  > 2 つ目の派生クラスを用意する場合、攻撃の派生クラスに対して、さらに派生させる必要があり、殴る and ガード・殴る and かわす・殴る and 受け止める、蹴る and ガード、蹴る and かわす…ととても多くの派生クラスが必要になる。
  > どの方法も、要素が増えるたびに辛くなりそうだ。
  > 前置きが長くなったが、上記のような問題を避けるために、新たな考えを導入する。
  > 攻撃に関しては、攻撃の振る舞いに責務を持つ、Kogeki オブジェクトを新たに作り、防御に関しては、Bogyo オブジェクトを新たに作り、キャラクターに保持させてしまうのだ。
  > 先ほどは、キャラクターを抽象クラスにして派生させるという方法を提示したが、今回は、攻撃に責務を持つ Kogeki という抽象クラスを用意し、その派生クラスとして、Naguru クラスと Keru と Nageru クラスを用意する。
  > こうすることで、攻撃に関する振る舞いを Kogeki オブジェクトに押し込んでしまうことができる。
  > いわば、「攻撃技」という共通性に対して、「殴る・蹴る・投げる」という流動的要素が存在しており、「攻撃技」という抽象クラスで「殴る・蹴る・投げる」という派生クラスを隠蔽し、使用する側である、キャラクターには、「攻撃技」という抽象クラスを保持させるのである。
  > これこそまさに、クラス継承よりもオブジェクトの集約を多用するということであり、流動的要素を見つけ出し、それをカプセル化するということでもある。
  > キャラクターオブジェクトは、自身が攻撃の振る舞いを持つのではなく、Kogeki オブジェクトに振る舞いを委譲してしまう。 Kogeki オブジェクトが kogeki メソッドを持つことにすれば、 キャラクターオブジェクトからすると、攻撃の実際の振る舞いは関知しない状態となり、Kogeki オブジェクトの kogeki メソッドを呼び出すだけとなる。 仮に今後、攻撃技に関する振る舞いが増えたとしても、キャラクターオブジェクトに変更を入れることなく、攻撃技に関しての振る舞いを拡張することができるようになる。 これは、Bogyo オブジェクトに関しても同じことがいえる。

カプセル化しない場合とした場合の比較 ↓

```python
class Triangle(object):
    """三角形クラス"""
    def __init__(self,points):
        """初期化"""

    def area(self):
      """三角形の面積計算"""


class Rectangle(object):
    """四角形クラス"""
    def __init__(self,points):
        """初期化"""

    def area(self):
      """四角形の面積計算"""


class Circle(object):
    """円クラス"""
    def __init__(self,points):
        """初期化"""

    def area(self):
      """円の面積計算"""
```

```python
class Figure(object):
    """抽象図形クラス"""
    def __init__(self):
        """初期化"""
    def area(self):
        """面積計算"""
        """変更多い"""


class Triangle(Figure):
    """Figureクラスを継承した三角形クラス"""
    def __init__(self):
        """初期化"""


class Rectangle(Figure):
    """Figureクラスを継承した四角形クラス"""
    def __init__(self):
        """初期化"""
```

### 2.7 名前重要（Naming is important）

- 変数、関数、オブジェクトの命名は最重要課題

- プログラマ同士はコードの上で「名前」を通じて会話する

- 名前はコードを読む人の UI

- よい名前で読み手のメンタルマッピングが回避される

  - 良い命名がされていると、これはこういう変数が入っていて、この関数はこういう処理をしていて、、、というのを一時記憶することなくコードを読める

- 効果と目的が分かるように命名する。（手段は処理部分で説明する）

- ループバックチェック（名前に可逆性を持たせる）
  - 処理内容-名前の両者を行き来できるように

---

- 命名がとても重要という話は「リーダブルコード」でも力説されていた

- 品詞を意識することも大切。動詞なのか、名詞なのか

- `hasCookie()`とか`isObject()`みたいな命名は条件節で分かりやすい

- set や get という動詞を使うときは注意

- プログラミングの文脈における単語の意味を覚える
