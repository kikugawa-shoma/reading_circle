## 6.4ドッグフーディング
- 自分で開発したソフトウェアは必ず自分で使って使用感を確かめる・バグをチェックする

- その際になるべくユーザーが使うように使うことを心がける
  - 開発者視点はNG

---
- そうはいっても開発者視点になってしまうことを避けるのはなかなか難しい・・・

## 6.5 ラバーダッキング
- ラバーダック = あひるちゃん
- 発生している問題や、問題のあるコードを誰かに説明する。説明する対象は人でなくてもよい

- 説明することで原因に気づくことができる。

- 最適なのは説明対象はエンジニア。緊張感を持って話すことができる

- ただし、人に話しかけた場合のコストは2倍。説明対象が無機物がコスパが良い

---
- こういう体験したことあるはず
- 質問しに行ったら話してるうちに解決したみたいな話

## コンテキスト

- コンテキスト：文脈、周囲の状況、背景

- コードの読み書きにはコンテキストを利用するとよい。
  - モジュール名や関数名によって読み手にコンテキストを伝える

- プログラミングは問題解決の手段。問題を正確に解くには背景知識が必須

- コンテキストをうまく使ってコードを理解しやすく書くことが大切
  - get、set、pop、appendなどもコンテキストを伝えていると言える

- コードを書くとき:コンテキストを先に伝えるように書く

- コードを読むとき:コンテキストを先に把握できるように読む

- 作業依頼時コンテキストを意識
  - 作業者の技術レベル高い⇒依頼作業の説明はコンテキストを伝えられれば必要十分。後は作業者がよしなにやるし、下手にやることを細かく指示するよりもパフォーマンスが高い

- コンテキストは日常生活でも大切(本の見出し、単語の無意識的な意味判断)

- チームはハイコンテキストだとコミュニケーションコストを下げられる
  - ただし新人が入ったときなどはフォローすべき

- コード共通化する際の判断基準もコンテキスト志向で考える
  - 同じコードでもコンテキストが違えば、今後再度分ける必要が出てくる可能性が高い
  - コードの共通化=コードの行数は減るが、コードの依存度を高まる
    - なるべく依存度が高まらない部分で共通化するべき（そのためにはコンテキストを共有しているかという観点が必要）

- 人の脳のコンテキストスイッチ
  - コンテキストスイッチ:マルチプロセスを実現する（あたかも実現しているかのように見せる）ためにCPUやメモリの状態を退避したり復元したりすること
  - [youtube](https://youtu.be/Ik1_AzopJG4?t=18)

- システムシンキング
  - システムを真に理解する=システムの構成要素の理解+構成要素の関わり合いの理解

  - ソフトウェアによる問題解決=解法(アルゴリズム)の知識+問題に対する知識(問題そのもの+問題を取り巻くコンテキスト)
    - システムシンキングが必要不可欠
  - ドメイン駆動設計
    - ドメイン:ソフトウェアで解決しようとしている関心事。ソフトウェアのコンテキスト
    - ドメインモデルをソフトウェア開発の中心に置く
    - プログラマとドメインの専門家がドメインモデルに沿ってコミュニケーションすることでドメインモデルをより深化させる
    - ドメインモデルの深化もアジャイル的に行っていく

- エピステーメ・テクネ・フロネシス
  - エピステーメ：科学・普遍的な真理
  - テクネ：工学。アルゴリズム
  - フロネシス：実践的な智慧。個別具体な問題に対処する際に、その問題のコンテキストに応じて適切な施策を検討する力

  - ソフトウェアによる問題解決ではフロネシスを発揮して個別具体的な状況に対して、各コンテキストを理解し、全体最適な判断をすることが大切

- 関係主義的な考えで障害原因を探ると効果的なことが多い
  - 「存在」=「実体」と「実体同士の関係」
  - 関係主義：「実体同士の関係に重きを置く立場」
  - 障害原因の究明には「関係主義」的に考える
    - ライブラリとの関係、実行環境との関係、etc・・・
    - コードそのものばかり見ない


---
- 熟年夫婦の阿吽の呼吸
- slackのメンションを飛ばしすぎない
- バタフライ効果
- フロネシス：この問題に対してはこれを使うと効果的みたいなことを判断するために必要とされる知識
